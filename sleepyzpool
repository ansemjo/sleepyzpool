#!/usr/bin/env python3

# Copyright (c) 2023 Anton Semjonov
# Licensed under the MIT License

from subprocess import run, Popen, PIPE, TimeoutExpired
import argparse, sys, signal, tomllib

# get config file path from commandline
parser = argparse.ArgumentParser()
parser.add_argument("config", help="path to the TOML config file", type=argparse.FileType("rb"), default="/etc/sleepyzpool.toml", nargs="?")
parser.add_argument("--quiet", "-q", help="silence iostat log when all disks are asleep", action="store_true")
parser.add_argument("--check", "-C", help="check current disk status and exit", action="store_true")
parser.add_argument("--now", "-y", help="send disks to sleep right now and exit", action="store_true")
args = parser.parse_args()

# read the config from file and pray you got the format right
conf = tomllib.load(args.config)
zpool = conf.get("zpool")
assert isinstance(zpool, str) and len(zpool), "'zpool' must be the zpool name to watch"
disks = conf.get("disks")
assert isinstance(disks, list) and len(disks), "'disks' must be an array of devices to standby"
timeout = conf.get("timeout", 20)
assert isinstance(timeout, int) and timeout > 0, "'timeout' must be a positive timout in minutes"


def in_standby(disk: str) -> bool | None:
  "Check if a disk is in standby / spun down with hdparm."
  try:
    check = run(["hdparm", "-C", disk], capture_output=True, check=True, timeout=2)
    lines = check.stdout.splitlines(keepends=False)
    if len(lines) > 3 or lines[0] != b"" or lines[1] != f"{disk}:".encode():
      raise ValueError("unexpected command output from 'hdparm -C'")
    return lines[2].endswith(b"standby")
  except TimeoutExpired:
    return None

def issue_standby(disk: str) -> bool:
  "Send a disk into low-power standby mode / spin down."
  try:
    run(["hdparm", "-y", disk], capture_output=True, check=True, timeout=10)
    return True
  except TimeoutExpired:
    return False
  
# handle check and now flags
if args.check:
  for disk in disks:
    print(f"{disk}: {'standby' if in_standby(disk) else 'active'}")
  exit(0)

if args.now:
  for disk in disks:
    print(f"{disk}: issuing standby command")
    issue_standby(disk)
  exit(0)

# keep a counter of idle minutes for each disk
counters = { disk: 0 for disk in disks }

# silence logs when all disks are spun down as long as there is no activity
spindown = { disk: False for disk in disks }

# start the zpool iostat and parse the stdout lines
# -y : skip first line (since boot)
# -H : scripted mode without header
iostat = Popen(["zpool", "iostat", "-yH", zpool, "60"], stdout=PIPE)

# register a signal handler to terminate on ^C
def interrupt(signal, frame):
  iostat.terminate()
signal.signal(signal.SIGINT, interrupt)

# handle iostat output until it's killed
for line in iostat.stdout:
  
  # split the stats from line
  alloc, free, r_ops, w_ops, r_bw, w_bw = line.strip().decode().split("\t")[1:]

  # if there were any ops, reset all counters and skip rest of the loop
  if any(( s != "0" for s in [r_ops, w_ops, r_bw, w_bw] )):
    for disk in counters.keys():
      counters[disk] = 0
      spindown[disk] = False

  # otherwise iterate over disks and increment counter when awake
  else:
    for disk in disks:
      standby = in_standby(disk)

      # keep counter at zero as long as the disk is in standby
      if standby is True:
        counters[disk] = 0
        spindown[disk] = True

      # increment in active state and check if limit was reached
      # don't reset spindown map if there was no activitiy, though
      if standby is False:
        counters[disk] += 1
        if counters[disk] >= timeout:
          print(f"hdparm\tissuing standby: {disk}", flush=True)
          if issue_standby(disk):
            counters[disk] = 0

      # ignore if hdparm timed out
      if standby is None:
        print(f"ERR: hdparm timed out for {disk}, skipping", file=sys.stderr, flush=True)
        continue

  # if all disks are inactive, silence the logs
  if args.quiet and all(spindown.values()):
    continue

  # print this iteration's values and wait for next iostat line
  print(f"iostat\tops[{r_ops}, {w_ops}]  bw[{r_bw}, {w_bw}]  idle{list(counters.values())}", flush=True)


# wait for process to end after interrupt
iostat.communicate()
